QUESTION : Given an array arr of 0s and 1s. Find and return the length of the longest subarray with equal number of 0s and 1s.

Examples:

Input: arr[] = [1, 0, 1, 1, 1, 0, 0]
Output: 6
Explanation: arr[1...6] is the longest subarray with three 0s and three 1s.
Input: arr[] = [0, 0, 1, 1, 0]
Output: 4
Explnation: arr[0...3] or arr[1...4] is the longest subarray with two 0s and two 1s.
Input: arr[] = [0]
Output: 0
Explnation: There is no subarray with an equal number of 0s and 1s.
Constraints:
1 <= arr.size() <= 105
0 <= arr[i] <= 1







SOLUTION : class Solution {
  public:
    int maxLen(vector<int> &arr) {
        // Your code here
        int n = arr.size();
        unordered_map<int,int> firstIndex;
        firstIndex.reserve(n*2);
        firstIndex[0] = -1;
        
        int sum = 0;
        int maxLen = 0;
        
        for (int i = 0; i <n; ++i){
            sum += (arr[i] == 0 ) ? -1 : 1;
            
            if (firstIndex.find(sum) != firstIndex.end()){
                maxLen = max(maxLen , i - firstIndex[sum ]);
            }
            else{
                firstIndex[sum] = i;
            }
        }
        
        
        
        return maxLen;
        
        
        
    }
};










  
