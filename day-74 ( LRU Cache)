class LRUCache {
    
    
    private:
        struct Node {
            int key , value;
            Node* prev;
            Node* next;
            Node(int k, int v) : key(k) , value(v),prev(NULL),
            next(NULL){
                
            }
        };
    
        int capacity;
        unordered_map<int,Node*> cache;
        Node* head;
        Node* tail;
        
        void addNode(Node* node){
            node->next = head->next;
             node->prev = head;
             head-> next->prev = node;
             head->next = node;
        }
    
    void removeNode(Node* node){
         Node* prevNode = node-> prev;
         Node* nextNode = node-> next;
         prevNode->next = nextNode;
         nextNode->prev = prevNode;
    }
    
    
    void moveToHead(Node* node){
        removeNode(node);
        addNode(node);
    }
    
    Node* popTail(){
        Node* node = tail -> prev;
        removeNode(node);
        return node;
    }
    
    
    
    
    
    
    
    
  public:
    LRUCache(int cap) {
        // code here
        capacity = cap;
        head= new Node(0,0);
        tail = new Node(0,0);
        head -> next = tail;
        tail -> prev = head;
        
        
    }

    int get(int key) {

        if (cache.find(key) == cache.end()) return -1;
        
        Node* node = cache[key];
        moveToHead(node);
        return node -> value;

    }

        
    void put(int key, int value) {
        // code here
        if (cache.find(key) != cache.end()){
            Node* node = cache[key];
            node->value = value;
            moveToHead(node);
        }else{
            Node* node = new Node(key,value);
            cache[key] = node;
            addNode(node);
        }
        if ((int)cache.size() > capacity){
            Node* lru = popTail();
            cache.erase(lru->key);
            delete lru;
        }
        
        
        
    }
};








